//------------------------------------------------------------------------------//
// Essa Rotina é responsável pelo controle do sistema de irrigação inteligente  //
// "Irrigacerto"                                                                //
// Data Início:13/05/2010              Data Término: 19/06/2010                 //
// Programadores:   João Paulo Vieira                                           //
//                  Samir Angelo Milani Martins                                 //
//------------------------------------------------------------------------------//
#include <18F4550.h> // Inclui arquivo de definições do microcontrolador
#device  ADC=10;      // Configurando conversor AD para 10 bits
#use     delay(clock=8000000) //Definindo clock do microcontrolador
#FUSES   INTRC_IO,NOWDT,NOPUT,NOPROTECT,NOMCLR,NODEBUG,NOBROWNOUT,NOLVP,NOCPD,NOWRT
#include "F:\Projeto18F4550\Projeto18F4550\Rotinas\driver_lcd.c" // Incluindo arquivo com driver do LCD


//------------------------------------------------------------------------------
// Associando TAGs aos pinos de entrada e saída
//------------------------------------------------------------------------------

#define tcl_enter       (!input(PIN_D5)) 
#define tcl_baixo       (!input(PIN_D6))
#define tcl_cima        (!input(PIN_D4))
#define liga_bomb       output_high(PIN_D0)
#define des_bomb        output_low(PIN_D0)
#define abre_valv       output_high(PIN_D1)
#define fecha_valv      output_low(PIN_D1)     
#define LED                PIN_D2
#define state_cima            1
#define state_baixo           2
#define state_enter           3
#define debounce              0
#define ligado                1
#define desligado             0
#define state_bomb         input_state(PIN_D0)
#define state_valv         input_state(PIN_D1)

//------------------------------------------------------------------------------
// Protótipos das funções que serão utilizadas
//------------------------------------------------------------------------------

void  update_display(void);
void  check_buttons(void);
int16 read_AD(int ch);
void  update_sp(void);

//------------------------------------------------------------------------------
// Definindo variáveis globais
//------------------------------------------------------------------------------
int1 tcl_cima_press=0,tcl_baixo_press=0,tcl_enter_press=0;  // Definindo variável de 1 bit para estados das teclas de entrada
int8 filtro1=debounce;                                      // Definindo valores para filtros debounce das teclas
int8 filtro3=debounce;
int8 filtro2=debounce;
int8 state=1;                                               //Definindo valores iniciais para a máquina de estados
int16 set_point_on=2;                                       //Definindo valor inicial do set_point_on  2
int16 set_point_off=4;                                      //Definindo valor inicial do set_point_off 4
int16 aux,aux1;                                             //Variáveis auxiliares
float umi,tempamb;                                          //Variável umidade e temperatura ambiente

//------------------------------------------------------------------------------
// Função para leitura das teclas e filtro debounce
//------------------------------------------------------------------------------

void check_buttons(void)
{
//------------------------------------------------------------------------------
// ENTRADA1-Tcl_acima
//------------------------------------------------------------------------------
        if(tcl_cima)     // Relativo ao pino Pino A2 do PIC                              
          {
            if(!(tcl_cima_press))   // Flag indicando se botão foi pressionado
            {
               if(filtro1!=0)      // valor do debounce
               {
                  filtro1--;
               }
               else
               {
               tcl_cima_press=1;  //  flag que indica se botao foi pressionado ou nao depois do filtro
                                 
               }
            }
          }
        else
            {  
              filtro1=debounce;
              tcl_cima_press=0;               
            }        
//------------------------------------------------------------------------------
// ENTRADA2-tcl_baixo
//------------------------------------------------------------------------------
        if(tcl_baixo)     // Relativo ao pino Pino A3 do PIC                              
           {
            if(!(tcl_baixo_press))   // Flag indicando se botão foi pressionado
            {
               if(filtro2!=0)      // valor do debounce
               {
                  filtro2--;
               }
               else
               {
               tcl_baixo_press=1;  //  flag que indica se botao foi pressionado ou nao depois do filtro
                                    
               }
         
            }
            
           }
        else
            {  
              filtro2=debounce;
              tcl_baixo_press=0; 
            }
//------------------------------------------------------------------------------
// ENTRADA3-tcl_enter
//------------------------------------------------------------------------------
        if (tcl_enter)     // Relativo ao pino Pino A4 do PIC                              
          {
            if(!(tcl_enter_press))   // Flag indicando se botão foi pressionado
            {
               if(filtro3!=0)      // valor do debounce
                {
                  filtro3--;
                }
               else
               {
                 tcl_enter_press=1;  //  flag que indica se botao foi pressionado ou nao depois do filtro                                
               }
            }
          }
        else
            {  
              filtro3=debounce;
              tcl_enter_press=0;            
            }
}

//------------------------------------------------------------------------------
// Função que lê entrada analógica ch do PIC
//------------------------------------------------------------------------------
int16 read_AD(int ch)
{
  int16 temp;          //Definindo variável auxiliar para leitura do A/D
  set_adc_channel(ch); //Selecionando o canal A/D que irá ser feita conversão
  delay_us(30);        //Tempo para carga capacitor de Hold 
  temp=read_adc();     //Efeturando conversão 
  return temp;         //Retornando valor da conversão 
}


//------------------------------------------------------------------------------
// Função que atualiza os valores dos pontos de atuação da bomba
//------------------------------------------------------------------------------

void update_sp(void)
{
  if (state==6)
   {
    check_buttons();
    if(tcl_baixo_press)
       set_point_on--;
     else if(tcl_cima_press)
       set_point_on++;
   }
  if(state==7)
   {
    check_buttons();
    if(tcl_baixo_press)
       set_point_off--;
     else if(tcl_cima_press)
       set_point_off++;
   }
}
//------------------------------------------------------------------------------
// Máquina de estados para criação dos menus no LCD
//------------------------------------------------------------------------------
void update_display(void)
{
   switch(state)
 {
        
        case 1:           // Estado 1 : Estado inicial de operação inicial
           
            printf(lcd_putc, "Sistema Controle\n");
            lcd_gotoxy(3,2);  // Deslocandos cursor para linha 2 coluna 3
            printf(lcd_putc,"IrriGa Certo");
          
            check_buttons();  // Lendo teclas de entrada
            if(tcl_enter_press) 
              state =2;      // Aponta para o próximo estado
            
        
            
            break;           // Sai do switch
            
        case 2:           //Estado 2: Estado de indicação de temperatura no LCD  
            
            printf(lcd_putc, " Temp. Ambiente \n");
            lcd_gotoxy(6,2); // Deslocando cursor para linha 2 coluna 6
            printf(lcd_putc,"%2.2f C",tempamb); // Colocando valor de temperatura ambiente 
                        lcd_gotoxy(1,1);
            lcd_putc("                ");
            lcd_gotoxy(1,2);
            lcd_putc("                ");
            check_buttons(); // Lendo teclas de entrada
            if(tcl_baixo_press) //Verificação da transição para próximo estado
               state=3;    // Apontando para o estado 3 (Umidade) 
            
            break;
            
        case 3: // Estado 3: Estado de indicação de umidade no LCD
           
            printf(lcd_putc, " Umidade do Solo\n");
            lcd_gotoxy(6,2); // Deslocando cursor para linha 2, coluna 6
            printf(lcd_putc,"%2.2f C",umi); // Colocando valor de umidade no solo;
                       
            check_buttons(); // Lendo teclas de entrada
            if(tcl_cima_press) //Verificação da transição para próximo estado
                state=2;       // Apontando para o estado 2 (Temperatura)
              else if(tcl_baixo_press)
                state=4;         
           
           break;

        case 4:
            printf(lcd_putc, "Bomba~ ");
            if (state_bomb==ligado)
              {
               lcd_gotoxy(10,1); // Deslocando cursor para primeira linha, sexta coluna
               printf(lcd_putc," ON\n",); // Colocando estado da bomba na tela;
              }   
             else if (state_bomb==desligado)
              {
                lcd_gotoxy(10,1); // Deslocando cursor para primeira linha, sexta coluna
                printf(lcd_putc,"OFF \n",); // Colocando valor de umidade no solo;
              }
            lcd_gotoxy(1,2); // Deslocando cursor para segunda linha, primeira coluna
            printf(lcd_putc, " Valvula~");
            if (state_valv==ligado)
              {
                lcd_gotoxy(11,2); // Deslocando cursor para primeira linha, sexta coluna
                printf(lcd_putc,"ON",); // Colocando estado da bomba na tela;
              }   
             else if (state_valv==desligado)
              {
                lcd_gotoxy(10,2); // Deslocando cursor para linha 1 coluna 6
                printf(lcd_putc,"OFF",); // Colocando valor de umidade no solo no LCD
              }
          
            check_buttons(); // Lendo teclas de entrada
           if(tcl_cima_press)  // Transição para o estado Umidade do solo
                state = 3;
            else if(tcl_baixo_press) // Transição para o estado Ajuste Setpoint
                state = 5;
                      
           break;
               
           
        case 5:
           
            printf(lcd_putc,"Ajuste Setpoint\n",);
            lcd_gotoxy(3,2); 
            printf(lcd_putc," Press Enter",);
                              
            check_buttons(); // Lendo teclas de entrada
           
            if(tcl_enter_press) // Transição entre estados 
               state = 6;
             else if (tcl_cima_press)  
               state = 4;
            
            break;
   
        case 6:
            lcd_gotoxy(1,1);
            printf(lcd_putc," Ajuste Setpoint \n",); // Colocando valor de set point da valvula;
            lcd_gotoxy(4,2); // Deslocando cursor para primeira linha, sexta coluna
            printf(lcd_putc,"ON= %ld",set_point_on); // Colocando valor de set point da valvula; 
                       
            update_sp(); // Atualizando o valor dos setpoints
           
            check_buttons();
           
            if (tcl_enter_press)
             {
               state=7;
             }
            
            break;
        case 7:
       
            printf(lcd_putc,"Ajuste Setpoint \n",); // Colocando valor de set point da valvula;
            lcd_gotoxy(4,2); // Deslocando cursor para Linha 2, coluna 4
            printf(lcd_putc,"OFF= %ld",set_point_off); // Colocando valor de setpoint_off da valvula;
           
            update_sp();// Atualizando o valor dos setpoints 
 
            check_buttons();
           
            if (tcl_enter_press)
              state=5;
 
            break;
         
        default:
            break;
 }
}

//------------------------------------------------------------------------------
// Rotina Princiapal
//------------------------------------------------------------------------------
void main(void)
{    

//------------------------------------------------------------------------------
// Inicializações
//------------------------------------------------------------------------------

   setup_oscillator(OSC_8MHZ|OSC_INTRC); 
   setup_adc_ports(AN0_TO_AN1);  //Inicializando conversores A/D do PIC para portas A0,A1
   setup_adc(ADC_CLOCK_INTERNAL); // Configurando frequência de amostragem
   lcd_init();                    // Inicializando LCD  

//------------------------------------------------------------------------------
// Loop princiapal do programa
//------------------------------------------------------------------------------
 
for(;;)
 {
//------------------------------------------------------------------------------
// Monitoramento de execução do programa 1

  lcd_gotoxy(1,1);
            lcd_putc("                ");
            lcd_gotoxy(1,2);
            lcd_putc("                ");

//------------------------------------------------------------------------------ 
    output_low(LED);
    delay_ms(300);
//------------------------------------------------------------------------------
// Leitura dos Canais A/D do PIC
//------------------------------------------------------------------------------
    aux=read_AD(0);          // Leitura do canal AN0 referente ao sensor de temperatura
    tempamb=aux*(5.0/1023);  // Polinômio de calibração do sensor de temperatura
    aux1=read_AD(1);         // Leitura do canal AN1 referente ao sensor de umidade
    umi=aux1*(5.0/1023);     // Polinômio de calibração do sensor de temperatura
 
//------------------------------------------------------------------------------
// Atualização do display
//------------------------------------------------------------------------------ 
    update_display(); // Máquina de Estados para geração de menus 
    delay_ms(220);    // Delay para transição entre estados do display
 
//------------------------------------------------------------------------------
// Lógica de Controle do Sistema de irrigação
//------------------------------------------------------------------------------ 

    if(umi<=set_point_on)
     {
      abre_valv;
      liga_bomb; 
     }
     else if (umi>=set_point_off)
      {
       fecha_valv;
       des_bomb;
      }
 
//------------------------------------------------------------------------------
// Monitoramento de execução do programa 2
//------------------------------------------------------------------------------ 
    output_high(LED);
    delay_ms(300);
 }   
      
}

